{"version":3,"sources":["../src/datasource.js"],"names":["ndjsonStream","rxjs","StreamingDatasource","instanceSettings","$q","backendSrv","templateSrv","type","url","name","q","withCredentials","headers","basicAuth","length","options","subject","Subject","metrics","request","Request","fetch","then","default","response","body","reader","s","getReader","read","result","done","seriesList","oldestTimeMS","earliestTimeMS","range","from","unix","element","value","indicator","target","series","datapoints","timestamp","push","filter","p","to","ts","Object","keys","map","key","next","data","resolve","subscribe","doRequest","method","status","message","title"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from 'lodash';\nimport * as ndjsonStream from './vendor/ndjson.js';\nimport * as rxjs from './vendor/rxjs.umd.min.js';\nimport moment from 'moment';\nexport class StreamingDatasource {\n  constructor(instanceSettings, $q, backendSrv, templateSrv) {\n    this.type = instanceSettings.type;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.q = $q;\n    this.backendSrv = backendSrv;\n    this.templateSrv = templateSrv;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.headers = { 'Content-Type': 'application/json' };\n    if (typeof instanceSettings.basicAuth === 'string' && instanceSettings.basicAuth.length > 0) {\n      this.headers['Authorization'] = instanceSettings.basicAuth;\n    }\n  }\n\n  query(options) {\n    var subject = new rxjs.Subject();\n    var metrics = {};\n\n    var request = new Request(`${this.url}`);\n\n    fetch(request)\n      .then(response => {\n        // In our case our messages are new-line delimmited json, but partial messages\n        // may come across the wire, so we use ndjson to help manage stitching them together\n        return ndjsonStream.default(response.body);\n      })\n      .then(s => {\n        const reader = s.getReader();\n        let read;\n        reader.read().then(\n          (read = result => {\n            if (result.done) {\n              return;\n            }\n            const seriesList = [];\n            let oldestTimeMS;\n            let earliestTimeMS = options.range.from.unix() * 1000;\n\n            const element = result.value;\n            var indicator = {\n              target: element.series,\n              datapoints: [],\n            };\n\n            oldestTimeMS = element.timestamp * 1000;\n            indicator.datapoints.push([element.value, element.timestamp * 1000]);\n\n            let series = metrics[indicator.target];\n            if (!series) {\n              series = { target: indicator.target, datapoints: [] };\n              metrics[indicator.target] = series;\n            }\n            series.datapoints = [...series.datapoints, ...indicator.datapoints];\n\n            // Slide the \"window\" and remove older points\n            series.datapoints = series.datapoints.filter(\n              p => p[1] > oldestTimeMS - (options.range.to.unix() * 1000 - options.range.from.unix() * 1000)\n            );\n            if (series.datapoints[0] && series.datapoints[0][1] && series.datapoints[0][1] > earliestTimeMS) {\n              earliestTimeMS = series.datapoints[0][1];\n            }\n            seriesList.push(series);\n\n            const ts = Object.keys(metrics).map(key => {\n              return metrics[key];\n            });\n\n            subject.next({\n              data: ts,\n              range: { from: moment(earliestTimeMS), to: moment(oldestTimeMS) },\n            });\n            reader.read().then(read);\n          })\n        );\n      });\n\n    return this.q.resolve({\n      subscribe: function(options) {\n        return subject.subscribe(options);\n      },\n    });\n  }\n\n  testDatasource() {\n    return this.doRequest({\n      url: this.url + '/',\n      method: 'GET',\n    }).then(response => {\n      if (response.status === 200) {\n        return { status: 'success', message: 'Data source is working', title: 'Success' };\n      }\n    });\n  }\n}\n"]}