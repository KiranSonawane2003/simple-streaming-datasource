{"version":3,"sources":["../src/stream_handler.js"],"names":["ndjsonStream","rxjs","StreamHandler","options","datasource","ds","subject","Subject","subscribe","throttledSubject","pipe","operators","throttleTime","reader","metrics","request","Request","url","targets","numSeries","fetch","then","default","response","body","s","getReader","readHandler","read","result","done","handleMessage","value","msg","oldestTimestamp","range","from","unix","mostRecentTimestamp","to","timestamp","series","target","datapoints","filter","p","ts","Object","keys","map","key","next","data","cancel"],"mappings":"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","file":"stream_handler.js","sourcesContent":["import moment from 'moment';\nimport * as ndjsonStream from './vendor/ndjson.js';\nimport * as rxjs from './vendor/rxjs.umd.min.js';\n\n// We return a StreamHandler wrapped in a promise from the datasource's\n// Query method. Grafana expects this object to have a `subscribe` method,\n// which it reads live data from.\nexport class StreamHandler {\n  constructor(options, datasource) {\n    this.options = options;\n    this.ds = datasource;\n    this.subject = new rxjs.Subject(); // Where we'll publish our data\n    this.subscribe = options => {\n      // To avoid destroying the browser with repaints, add a throttle (You may want to tweak this)\n      var throttledSubject = this.subject.pipe(rxjs.operators.throttleTime(100));\n      return throttledSubject.subscribe(options);\n    };\n    this.reader = null;\n    this.metrics = {}; // A local copy of our data that we'll operate on before sending to the rxjs Subject\n  }\n\n  open() {\n    var request = new Request(`${this.ds.url}?numSeries=${this.options.targets[0].numSeries}`);\n    fetch(request)\n      .then(response => {\n        // In the real world its likely that our json gets chopped into\n        // chunks when streamed from the backend. ndjsonStream handles\n        // reconstructing the newline-delimmited json for us.\n        return ndjsonStream.default(response.body);\n      })\n      .then(s => {\n        this.reader = s.getReader(); // Save the reader so we can cancel it later\n        let readHandler;\n\n        this.reader.read().then(\n          (readHandler = result => {\n            if (result.done) {\n              return;\n            }\n            this.handleMessage(result.value);\n            this.reader.read().then(readHandler);\n          })\n        );\n      });\n  }\n\n  handleMessage(msg) {\n    let oldestTimestamp = this.options.range.from.unix() * 1000;\n    var mostRecentTimestamp = this.options.range.to.unix() * 1000;\n\n    // Assuming the data we're being streamed in chronologically ordered\n    if (msg.timestamp > mostRecentTimestamp) {\n      mostRecentTimestamp = msg.timestamp;\n    }\n\n    // See if we have any data already for this target\n    let series = this.metrics[msg.series];\n    if (!series) {\n      series = { target: msg.series, datapoints: [] };\n      this.metrics[msg.series] = series;\n    }\n    series.datapoints = [...series.datapoints, [msg.value, msg.timestamp]]; // Add our new point to the end\n\n    // Slide the \"window\" by removing any points that are older than the latest point,\n    // minus the width of the current time range\n    series.datapoints = series.datapoints.filter(\n      p => p[1] > mostRecentTimestamp - (this.options.range.to.unix() * 1000 - this.options.range.from.unix() * 1000)\n    );\n\n    // Grab the timestamp of the earliest point still in the datapoints array, we'll\n    // move the time window forward to match it\n    if (series.datapoints[0] && series.datapoints[0][1] && series.datapoints[0][1] > oldestTimestamp) {\n      oldestTimestamp = series.datapoints[0][1];\n    }\n\n    const ts = Object.keys(this.metrics).map(key => {\n      return this.metrics[key];\n    });\n\n    this.subject.next({\n      data: ts,\n      range: { from: moment(oldestTimestamp), to: moment(mostRecentTimestamp) },\n    });\n  }\n\n  close() {\n    if (this.reader) {\n      this.reader.cancel('Close was called on streamHandler');\n    }\n  }\n}\n"]}