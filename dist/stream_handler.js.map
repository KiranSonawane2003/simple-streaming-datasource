{"version":3,"sources":["../src/stream_handler.js"],"names":["ndjsonStream","rxjs","StreamHandler","options","datasource","ds","subject","Subject","subscribe","throttledSubject","pipe","operators","throttleTime","reader","metrics","request","Request","url","fetch","then","default","response","body","s","getReader","read","result","done","handleMessage","value","msg","seriesList","oldestTimeMS","earliestTimeMS","range","from","unix","indicator","target","series","datapoints","timestamp","push","filter","p","to","ts","Object","keys","map","key","next","data","cancel"],"mappings":"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","file":"stream_handler.js","sourcesContent":["import moment from 'moment';\nimport * as ndjsonStream from './vendor/ndjson.js';\nimport * as rxjs from './vendor/rxjs.umd.min.js';\n\n// We return a StreamHandler wrapped in a promise from the datasource's\n// Query method. Grafana expects this object to have a `subscribe` method,\n// which it knows how to read live data from.\nexport class StreamHandler {\n  constructor(options, datasource) {\n    this.options = options;\n    this.ds = datasource;\n    this.subject = new rxjs.Subject();\n    this.subscribe = options => {\n      // To avoid destroying the browser with repaints, add a throttle\n      var throttledSubject = this.subject.pipe(rxjs.operators.throttleTime(1000));\n      return throttledSubject.subscribe(options);\n    };\n    this.reader = null;\n    this.metrics = {};\n  }\n\n  open() {\n    var request = new Request(`${this.ds.url}`);\n    fetch(request)\n      .then(response => {\n        // In the real world its likely that our json gets chopped into\n        // chunks when streamed from the backend. ndjsonStream handles\n        // reconstructing the newline-delimmited json for us.\n        return ndjsonStream.default(response.body);\n      })\n      .then(s => {\n        this.reader = s.getReader(); // Save the reader so we can cancel it later\n        let read; //handler\n\n        this.reader.read().then(\n          (read = result => {\n            if (result.done) {\n              return;\n            }\n\n            this.handleMessage(result.value);\n\n            this.reader.read().then(read);\n          })\n        );\n      });\n  }\n\n  handleMessage(msg) {\n    const seriesList = [];\n    let oldestTimeMS;\n    let earliestTimeMS = this.options.range.from.unix() * 1000;\n\n    var indicator = {\n      target: msg.series,\n      datapoints: [],\n    };\n\n    oldestTimeMS = msg.timestamp;\n    indicator.datapoints.push([msg.value, msg.timestamp]);\n\n    let series = this.metrics[indicator.target];\n    if (!series) {\n      series = { target: indicator.target, datapoints: [] };\n      this.metrics[indicator.target] = series;\n    }\n    series.datapoints = [...series.datapoints, ...indicator.datapoints];\n\n    // Slide the \"window\" and remove older points\n    series.datapoints = series.datapoints.filter(\n      p => p[1] > oldestTimeMS - (this.options.range.to.unix() * 1000 - this.options.range.from.unix() * 1000)\n    );\n    if (series.datapoints[0] && series.datapoints[0][1] && series.datapoints[0][1] > earliestTimeMS) {\n      earliestTimeMS = series.datapoints[0][1];\n    }\n    seriesList.push(series);\n\n    const ts = Object.keys(this.metrics).map(key => {\n      return this.metrics[key];\n    });\n\n    this.subject.next({\n      data: ts,\n      range: { from: moment(earliestTimeMS), to: moment(oldestTimeMS) },\n    });\n  }\n\n  close() {\n    if (this.reader) {\n      this.reader.cancel('Close was called on streamHandler');\n    }\n  }\n}\n"]}